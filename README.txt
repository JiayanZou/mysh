jz937

For this project, I have implemented my own custom terminal shell. It allows redirection and piping involving symbols of <, >, and |. It also handles some built-in commands, such as cd, which, exit, and pwd. It also allows the execution of terminal system level executables, such as grep, echo, tr, and make.

This project has been thoroughly tested, including both the batch and interactive mode. For the interactive mode, the welcome message is "Welcome to my shell!" and the exit message is "Exiting my shell.". I have tested all the built-in commands we have to implemented, and it works properly. The results of each would depend on the specific platform this project is being ran.

To test the batch mode, I have already created the file "batch_commands". This includes six commands to run, three of them are implementations of the built-in commands in terminal, which are cd and pwd. For the rest three, I have tested its ability to execute the executables: ls, which, and cat are executable. For the command, ls | wc -l, I have chosen this to test the program's power to handle piping. This command returns the number of files inside the folder P3, which is 7. I have also tested the "which" statements: "which grep" should return /usr/bin/grep. The last statement in this file tests the program's ability to handle the combination of redirection and piping. Specifically, it reads the content of test2.txt seen in this submission folder and capitalize all the letters, and put the results in a new file called "final_output.txt". 

To test my interactive mode, I have used the command ./mysh. It prints "Welcome to my shell!" at the very beginning, and the user can type in commands after the "mysh>". To test the mode, I first tested the efficiency of the built-in commands: cd, ls, which, exit, and pwd. When exit is typed with other arguments, it exit the program, printing the additional arguments typed, separated by spaces. When exit is typed alone, it simply prints the message "Exiting my shell." To test whether the child process returns "Command failed: Code 1", I have typed in the command called "grep" alone, with no other arguments (Which is illegal in the real case), and the last statement is "command Failed: Code 1." This demonstrated that this part is correct. I have also included the P2 in this folder, and have attempted to run P2 using this custom shell. I have typed in the command "make" as usual, and it successfully compiled P2. To execute P2, I have tested the effectiveness of wildcard *. To be specific, when I typed in /common/home/jz937/Downloads/P3/P2/test_files/Irregular/*, it executes all the files inside the "Irregular" folder of P2. However, when I typed in /common/home/jz937/Downloads/P3/P2/test_files/Irregular/t*1.txt, it only runs the file test1.txt. This shows that my wildcard works properly. When I typed in /common/home/jz937/Downloads/P3/P2/test_files/Basics/t*4.txt, it will return a code 1 for execv since there are no file with this t*4.txt format, and it prints out no such file 't*4.txt', which indicates that the program takes in t*4.txt as arguments when no match is found. So the wildcard is successful.

I am also able to create or decompress tar files using my personally implemented shell.